// High-level notional plan for lander autonomy.

/* To Do:
   - deal with potential random resets, i.e. due to radiation
   - save/resume state across sleep/wake cycle
   - fail operational
   - for each timeout: retry/failure semantics
*/

#include "OceanWorldDefs.h"

//Bool Lookup TrenchTargetReceived;
Real Lookup TrenchLength;
Real Lookup TrenchWidth;
Real Lookup TrenchSlopeAngle;
Real Lookup TrenchStart;

//Bool Lookup SampleGood;

Real Lookup time;
Real Lookup ExcavationTimeout;
Real Lookup TrenchTargetTimeout;
Real Lookup CollectAndTransferTimeout;


LibraryAction Stub(In String desc);
LibraryAction Downlink();
LibraryAction Image(In String desc);
LibraryAction DownlinkImage();
LibraryAction ImageSampleSite();

Command pprint (...);

// The following are adapted from the Phoenix lander activity dictionary.

Command RA_DIG (Real length, Real width, Real depth,
                Real slope_angle, Real trench_start[3],
                Real data_generation_rate, Real energy_consumption_rate);

Command RA_COLLECT ();

// TODO: find out what this is for
Command hga_comm (Real duration);

OceanWorldMission: Concurrence
{
    // Assumption: checkout is complete before this node starts.

    ContingencyMonitors: Concurrence
    {
        BatteryMonitor:
        {
            LibraryCall Stub(desc="Monitoring battery");
        }
        ThermalMonitor:
        {
            LibraryCall Stub(desc="Monitoring thermal");
        }
        UplinkMonitor:
        {
            LibraryCall Stub(desc="Monitoring for uplinks");
        }
    }

    Mission:
    {
        Panorama: Concurrence
        {
            StereoImage:
            {
                LibraryCall Stub(desc="Taking stereo panorama of landing site");
            }
        }

        ImageWorkspace:
        {
            LibraryCall Image(desc="workspace");
        }

        SurfaceInterrogation:
        {
            LibraryCall Stub(desc="Interrogating surface");
        }

        GetTrenchTarget:
        {
            // TODO: invoke comms, reset on failure.
            LibraryCall DownlinkImage();
            Try
            {
                GetInfoFromGround:
                {
                    Boolean numAttempts = 0;
                    RepeatCondition AttemptGround.outcome == FAILURE;
                    InvariantCondition numAttempts <= 1;
                    AttemptGround:
                    {
                        InvariantCondition
                            Lookup(time) < (AttemptGround.EXECUTING.START +
                                            Lookup(TrenchTargetTimeout));
                        EndCondition Lookup(TrenchTargetReceived);
                        LibraryCall Stub(desc="Getting trench target from ground");
                        numAttempts = numAttempts + 1;
                    }
                }
                pprint ("failed.");
                GetTrenchTargetOnboard:
                {
                    LibraryCall Stub(desc="Getting trench target onboard");
                }
            }
        }

        Excavation:
        {
            Boolean AcceptableDepth = false;
            RepeatCondition ! AcceptableDepth;
            InvariantCondition
                Lookup(time) < (Excavation.EXECUTING.START +
                                Lookup(ExcavationTimeout));
            DigAndFilm: Concurrence
                {
                    Boolean DiggingSafe = true;

                    DigTrench:
                    {
                        InvariantCondition DiggingSafe;
                        EndCondition (CommandHandle(RA_DIG) == COMMAND_SUCCESS ||
                                      Lookup(time) >= (DigTrench.EXECUTING.START
                                                       + DigTrenchTimeout));
                        RA_DIG (Lookup(TrenchLength), Lookup(TrenchWidth),
                                Lookup(TrenchDepth), Lookup(TrenchSlopeAngle),
                                Lookup(TrenchStart), DigDataGenerationRate,
                                DigEnergyConsumptionRate);
                    }
                    FilmDig:
                    {
                        Repeat DigTrench.State == EXECUTING;
                        LibraryCall Image(desc="trench");
                        Wait FilmInterval;
                    }
                    SenseDig:
                    {
                        Repeat DigTrench.State == EXECUTING;
                        DiggingSafe = StubTrue;
                        Wait SenseDigInterval;
                    }
                }
            RemoveTailings:
            {
                LibraryCall Stub(desc="Removing tailings")
            }
            LibraryCall Image(desc="Dig");
            AssessDepth:
            {
                AcceptableDepth = StubTrue;
            }
        }

        Downlink();

        CollectionAndTransfer:
        {
            Real SampleAmount;
            Boolean CollectMore = true;
            InvariantCondition
                Lookup(time) < (CollectionAndTransfer.EXECUTING.START +
                                Lookup(CollectAndTransferTimeout));
            RepeatCondition CollectMore;
            Collect:
            {
                EndCondition Lookup(SampleGood); // Material Property Sensing
                RA_COLLECT();
            }
            ImageSample:
            {
                ALIGN_SAMPLE_AND_CAMERA();  // position arm for imaging
                LibraryCall Image(desc="sample");
            }
            DownlinkSampleImage:
            {
                LibraryCall Downlink();
            }
            Transfer:
            {
                Dock:
                {
                    LibraryCall Stub(desc="Docking");
                }
                Unload:
                {
                    LibraryCall Stub(desc="Unloading");
                }
                MeasureSample:
                {
                    PostCondition !CollectMore;
                    LibraryCall Stub(desc="Measuring Sample");
                    CollectMore = StubFalse;
                }
                CapSample:
                {
                    LibraryCall Stub(desc="Capping Sample");
                }
                DeliverSample:
                {
                    LibraryCall Stub(desc="Measuring Sample");
                }
                LibraryCall ImageSampleSite();
            }
        }
        // Spawn a plan that does analysis.
        // Persists through sleep/wake cycle.
        // Details outside scope of our simulation.
        // Model time, energy, and possibly temperature.
        String id;
        id = StartPlan("SampleAnalysis");
    }
}
