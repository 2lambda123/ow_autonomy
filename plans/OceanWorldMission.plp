// High-level notional plan for lander autonomy.

/* To Do:
   - deal with potential random resets, i.e. due to radiation
   - save/resume state across sleep/wake cycle
   - fail operational
   - for each timeout: retry/failure semantics
*/

#include "OceanWorldDefs.h"

Real Lookup ExcavationTimeout;

LibraryAction Stub(String desc, Int duration);
LibraryAction Downlink();
LibraryAction Image();
LibraryAction DownlinkImage();
LibraryAction ImageSampleSite();

Command pprint (...);

// The following are adapted from the Phoenix lander activity dictionary.

Command RA_DIG (length: Real, width: Real, depth: Real,
                slope_angle: Real, trench_start: Real[3],
                data_generation_rate: Real, energy_consumption_rate: Real);

// TODO: find out what this is for
Command hga_comm (duration: Real); 

OceanWorldMission: Concurrence
{
    // Assumption: checkout is complete before this node starts.
    
    ContingencyMonitors: Concurrence
    {
        BatteryMonitor:
        {
            LibraryCall Stub(desc="Monitoring battery...");
        }
        ThermalMonitor:
        {
            LibraryCall Stub(desc="Monitoring thermal...");
        }
        UplinkMonitor:
        {
            LibraryCall Stub(desc="Monitoring for uplinks...");
        }
    }

    Mission: CheckedSequence
    {
        Panorama: Concurrence
        {
            StereoImage:
            {
                LibraryCall Stub(desc="Taking stereo panorama of landing site.");
            }
        }

        ImageWorkspace:
        {
            LibraryCall Image();
        }

        SurfaceInterrogation:
        {
            LibraryCall Stub(desc="Interrogating surface...");            
        }

        GetTrenchTarget:
        {
            // TODO: invoke comms, reset on failure.
            LibraryCall DownlinkImage();
            Try
            {
                GetInfoFromGround:
                {
                    Boolean numAttempts = 0;
                    RepeatCondition AttemptGround.OUTCOME == FAILURE;
                    InvariantCondition numAttempts <= 1;
                    AttemptGround:
                    {
                        InvariantCondition
                            Lookup(time) < (AttemptGround.EXECUTING.START +
                                            Lookup(GetTrenchTargetTimeout));
                        EndCondition Lookup(TrenchTargetReceived);
                        LibraryCall 
                            Stub(desc="Getting trench target from ground...");
                        numAttempts = numAttempts + 1;
                    }
                }
                pprint ("failed.");
                GetTrenchTargetOnboard:
                {
                    LibraryCall Stub(desc="Getting trench target onboard...");
                }
            }
        }

        Excavation: CheckedSequence
        {
            Boolean AcceptableDepth = false;
            RepeatCondition ! AcceptableDepth;
            InvariantCondition
                Lookup(time) < (Excavation.EXECUTING.START +
                                Lookup(ExcavationTimeout));
            DigAndFilm: Concurrence
                {
                    Boolean DiggingSafe = true;
              
                    DigTrench:
                    {
                        InvariantCondition DiggingSafe;
                        EndCondition (CommandHandle(RA_DIG) == COMMAND_SUCCESS ||
                                      Lookup(Time) >= (DigTrench.EXECUTING.START
                                                       + DigTrenchTimeout));
                        RA_DIG (Lookup(TrenchLength), Lookup(TrenchWidth),
                                Lookup(TrenchDepth), Lookup(TrenchSlopeAngle),
                                Lookup(TrenchStart), DigDataGenerationRate,
                                DigEnergyConsumptionRate);
                    }
                    FilmDig:
                    {
                        Repeat DigTrench.State == EXECUTING;
                        LibraryCall Image(desc="trench");
                        Wait(FilmInterval);
                    }
                    SenseDig:
                    {
                        Repeat DigTrench.State == EXECUTING;
                        DiggingSafe = StubTrue;
                        Wait(SenseDigInterval);
                    }
                }
            RemoveTailings:
            {
            }
            Image:
            {
            }
            AssessDepth:
            {
                AcceptableDepth = StubTrue;
            }
        }

        Downlink();
        
        CollectionAndTransfer:
        {
            InstrumentID InstrumentID;
            Real SampleAmount;
            Boolean CollectMore = true;
            InvariantCondition
                Lookup(time) < (CollectionAndTransfer.EXECUTING.START +
                                Lookup(CollectAndTransferTimeout));
            RepeatCondition CollectMore;
            Collect:
            {
                EndCondition Lookup(SampleGood); // Material Property Sensing
                RA_COLLECT();
            }
            ImageSample:
            {
                ALIGN_SAMPLE_AND_CAMERA();  // position arm for imaging
                LibraryCall Image();
            }
            DownlinkSampleImage:
            {
                LibraryCall Downlink();
            }
            Transfer:
            {
                Dock:
                {
                }
                Unload:
                {
                }
                MeasureSample:
                {
                    PostCondition !CollectMore;
                    CollectMore = StubFalse;
                }
                CapSample:
                {
                }
                DeliverSample:
                {
                }
                LibraryCall ImageSampleSite();
            }
        }
        // Spawn a plan that does analysis.
        // Persists through sleep/wake cycle.
        // Details outside scope of our simulation.
        // Model time, energy, and possibly temperature.
        String id;
        id = StartPlan("SampleAnalysis", "instrument", InstrumentID);
    }
}
