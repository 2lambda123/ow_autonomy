// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// Pattern summary: Execute a sequence of actions. If a fault is injected
// during a related action, the action will stop and end in the ABORTED state. 
// As long as the action is stopped, a backup action will repeat. If/when the 
// fault is cleared, the original action will automatically be attempted again.

// More specifically: If no faults are occurring, this plan will pan 180 
// degrees, and then unstow and stow the arm.
// If a relevant fault is injected, the plan will stop the current action 
// and start repeating a panning action as backup to the original action.
// If a fault is injected during an operation, that operation will only
// halt immediately if the fault injected is associated with it directly,
// i.e. an antenna fault during panning or an arm fault during 
// unstowing or stowing. 
// NOTE that as of September 8th, 2021, only the ant_pan_effort_failure
// will halt the panning action in this plan.

// IMPORTANT NOTE: When injecting a fault during an arm operation,
// you should wait until you see the action aborted, 
// e.g. "Stow finished in state ABORTED" before clearing the fault.
// Otherwise the action will show as completed, even though it halted
// before completing the task. This is due to some bugs in the simulator,
// and the fact that ROS action states are not exposed to PLEXIL.


#include "plan-interface.h"

LibraryAction InitializeAntennaAndArm ();

FaultHandlingPattern5:
{

  Boolean MissionInProgress = true;

  Boolean PanDone = false;
  Boolean UnstowDone = false;
  Boolean StowDone = false;

  log_info ("Starting FaultHandlingPattern5 plan...");

  LibraryCall InitializeAntennaAndArm ();

  RunMission: Concurrence
  {
    
    End !MissionInProgress;
    log_info ("Starting Mission...");

    LogPanError:
    {

      Start !PanDone && Lookup(AntennaFault);
    
      log_error ("Panning halted due to an antenna fault.");
    }

    LogUnstowError:
    {

      Start PanDone && !UnstowDone && Lookup(ArmFault);
    
      log_error ("Unstowing halted due to an arm fault.");
    }

    LogStowError:
    {

      Start UnstowDone && !StowDone && Lookup(ArmFault);
    
      log_error ("Stowing halted due to an arm fault.");
    }

    BackupPanning:
    {
      Real NewAngle;

      Repeat MissionInProgress;
      Start MissionInProgress && Lookup(ArmFault);
      Skip !MissionInProgress;

      // Might need to add logic so this only happens if antenna isnt operating 
      // Otherwise might be sending conflicting commands and it would be confusing

      NewAngle = (Lookup(PanDegrees) + 15) mod 360;
      log_info ("NewAngle: ", NewAngle);

      LibraryCall Pan (Degrees=NewAngle);
    
    }

    Mission: 
    {
    
      PanAntenna:
      {
        Real PanToleranceDegrees = 1.0;

        Repeat !PanDone;
        Start !Lookup(AntennaFault);
        Skip PanDone;

        LibraryCall Pan (Degrees=180);

        if abs(180 - abs(Lookup(PanDegrees))) < PanToleranceDegrees
        {
          PanDone = true;
        }

      }

      UnstowArm:
      {
        Repeat !UnstowDone;
        Start !Lookup(ArmFault);
        Skip UnstowDone;

        LibraryCall Unstow(); 
      
        // Since it is currently not possible to check the success/failure
        // of lander commands or the current arm position, we instead
        // use the following temporary check for when an arm fault is resolved
        // to denote that the arm has been unstowed.

        // The assumption is that if the above Unstow() has completed
        // and there is no arm fault, unstow is most likely successfully done.

        // Limitation: If the arm fault is cleared before Unstow() finishes,
        // successfully or otherwise, this check will incorrectly indicate
        // completion of unstowing altogether.

        UnstowDone = !Lookup(ArmFault);

      }

    
      StowArm:
      {
        Repeat !StowDone;
        Start !Lookup(ArmFault);
        Skip StowDone;

        LibraryCall Stow();

        // Since it is currently not possible to check the success/failure
        // of lander commands or the current arm position, we instead
        // use the following temporary check for when an arm fault is resolved
        // to denote that the arm has been stowed.

        // The assumption is that if the above Stow() has completed
        // and there is no arm fault, unstow is most likely successfully done.

        // Limitation: If the arm fault is cleared before Stow() finishes,
        // successfully or otherwise, this check will incorrectly indicate
        // completion of stowing altogether.
      
        StowDone = !Lookup(ArmFault);
  
      }

      MissionInProgress = false;
    }

  }

  log_info ("FaultHandlingPattern5 plan complete.");

}
