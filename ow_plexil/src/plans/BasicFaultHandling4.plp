// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// This goal is to minimize wasted power and lost time given mission constraints.
// In the future, this could be expanded to consider fault responses to each 
// specific fault, instead of responses to the four fault categories

// For testing, we will focus only on one imaging (Image) 
// and one arm task (UnstowStow) in this plan

// The goal is to demonstrate switching between these distinct tasks
// when an arm fault arises

// ** NOTES **
// In this plan we only consider arm faults, which do not affect image

// ** EXPECTED BEHAVIOR **
// If no arm issues: image, unstow, and stow
// If !ArmOK during arm task (UnstowStow), revert to image (need a timeout)
// If/when ArmOK again, reattempt UnstowStow (not implemented)

#include "plan-interface.h"

BasicFaultHandling4: Concurrence
{
  // Progress guards for mission continuation
  Boolean MissionInProgress = true;
  Boolean ArmTaskAlreadyTried = false;
  
  // Fault guard variable
  Boolean ArmOK = true;

  Real NewAngle = 0;

  CheckArmFaults:
  {
    // Update fault guard variable
    Repeat MissionInProgress;
    Start MissionInProgress;
    Skip !MissionInProgress;

    ArmOK = !Lookup(ArmFault);
    log_info ("ArmOK is: ", ArmOK);

    Wait 1;
    
  }

  HandleArmFaults:
  {
    Repeat MissionInProgress;
    Start MissionInProgress && !ArmOK; // Arm fault occurring
    Skip !MissionInProgress;
    
    // How do we only trigger this when an arm task is occurring?
    // Currently this will run even if just image in occurring assuming !ArmOK

    log_warning
      ("Arm fault occurring during arm operations, reverting to imaging task...");

    Image: // Will be a library call
    {
      log_info ("Running Image again...");
      NewAngle = Lookup(PanDegrees) + 90;
      SynchronousCommand pan_antenna (NewAngle);

      log_info ("You have 10 seconds to inject or remove faults...");
      Wait 10; // Give time for user to inject/remove faults
    }

    Wait 1;

    // #TODO When/how will we reattempt either Unstow or Search?

  }

  ReattemptArmTask:
  {
    Repeat MissionInProgress;
    Start MissionInProgress && ArmTaskAlreadyTried && ArmOK;
    Skip !MissionInProgress;

    log_info ("Reattempting arm task...");

    UnstowStow: // Will be a library call
    {
      Start ArmOK;
      ExitCondition !ArmOK;

      log_info ("Running UnstowStow...");
      SynchronousCommand unstow();
      SynchronousCommand stow();
      
      log_info ("You have 10 seconds to inject or remove faults...");
      Wait 10; // Give time for user to inject/remove faults

      ArmTaskAlreadyTried = true;
    }

  }

  Mission: UncheckedSequence
  {

    log_info ("Starting BasicFaultHandling4 plan...");

    Image: // Will be a library call
    {
      log_info ("Running Image...");
      SynchronousCommand pan_antenna (90);

      log_info ("You have 10 seconds to inject or remove faults...");
      Wait 10; // Give time for user to inject/remove faults
    }

    UnstowStow: // Will be a library call
    {
      Start ArmOK;
      ExitCondition !ArmOK;

      log_info ("Running UnstowStow...");
      SynchronousCommand unstow();
      SynchronousCommand stow();
      
      log_info ("You have 10 seconds to inject or remove faults...");
      Wait 10; // Give time for user to inject/remove faults

    }

    ArmTaskAlreadyTried = true;

    log_info ("BasicFaultHandling4 Mission complete.");
    MissionInProgress = false;
  } //end mission

  log_info ("BasicFaultHandling4 plan complete.");
} //end all
