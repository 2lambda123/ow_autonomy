// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// This plan builds on ReferenceMission2 by more complexly considering arm, 
// antenna, power and system faults and associated responses 
// (as opposed to just pausing as is done in ReferenceMission2)

// This goal is to minimize wasted power and lost time given mission constraints.
// In the future, this could be expanded to consider fault responses to each 
// specific fault, instead of responses to the four fault categories



#include "plan-interface.h"

LibraryAction MonitorPower (In Boolean continue,
                            InOut Boolean battery_temp_ok,
                            InOut Boolean battery_life_ok,
                            InOut Boolean battery_charge_ok,
                            InOut Boolean all_ok);

LibraryAction MonitorFaults (In Boolean continue,
                             InOut Boolean all_ok);

LibraryAction ImageLandingSite (In String InstanceName, In Boolean IgnoreCrash);

LibraryAction IdentifySampleTarget (InOut Real X,
                                    InOut Real Y,
                                    InOut Boolean Parallel,
                                    InOut Real GroundPos);

LibraryAction DigTrench (In Real X,
                         In Real Y,
                         In Real GroundPos,
                         In Real Length,
                         In Real BiteDepth,
                         In Integer NumPasses,
                         In Boolean Parallel);

LibraryAction RemoveTailings (In Real X,
                              In Real Y,
                              In Real GroundPos,
                              In Boolean Parallel);

LibraryAction CollectSample (In Real X,
                             In Real Y,
                             In Real GroundPos,
                             In Real Depth,
                             In Real Length,
                             In Boolean Parallel);

LibraryAction StartSampleAnalysis;

BasicFaultHandling: Concurrence
{
  // Guards to track current behavior #TODO: not sure if this type of guard is needed
  Boolean ImagingLandingSite = false;
 
  // Guards for mission continuation
  Boolean BatteryOK = true;
  Boolean NoFaults  = true;
  Boolean MissionInProgress = true;
  Boolean ArmOK = true; // Affects manipulator tasks
  Boolean AntennaOK = true; // Affects panning and tilting
  Boolean PowerOK = true; // Affects entire system, stop non-critical tasks
  Boolean SystemOK = true; // #TODO What do these affect? What about force torque faults?
  Boolean ForceTorqueOK = true;
  

  // Power monitoring
  Boolean BatteryTempOK = true;
  Boolean BatteryLifeOK = true;
  Boolean BatteryChargeOK = true;

  // Temporary guard for fault response while loops
  Boolean FinitePlease = false;

  // Guards to ensure re-attempt of interrupted nodes
  Boolean ImageInterrupted = false;
  Boolean UnstowInterrupted = false;
  Boolean SearchInterrupted = false;

  LibraryCall MonitorPower (continue = MissionInProgress,
                            battery_temp_ok = BatteryTempOK,
                            battery_life_ok = BatteryLifeOK,
                            battery_charge_ok = BatteryChargeOK,
                            all_ok = BatteryOK);

  LibraryCall MonitorFaults (continue = MissionInProgress,
                             all_ok = NoFaults);

  // Commented out for debugging infinite loop
  /*WaitForBatteryHealth:
  {
    Repeat MissionInProgress;
    Start MissionInProgress && !BatteryOK;
    Skip !MissionInProgress;

    log_warning
      ("Battery health issues, mission operations nominally paused...");
    Wait 10;
  }*/

  HandleFaults:
  {
    // Update fault guard variables, denoting fault type, if any
    Repeat MissionInProgress;
    Start MissionInProgress && !NoFaults;
    Skip !MissionInProgress;

    // Look up fault guard variables based on current state of faults in system
    ArmOK = !Lookup(ArmFault);
    AntennaOK = !Lookup(AntennaFault);
    PowerOK = !Lookup(PowerFault);
    SystemOK = !Lookup(SystemFault); // #TODO How should these come into play?
    // #TODO What about force torque system faults?

    Wait 10;
    
  }

  Mission: UncheckedSequence
  {

    // These 4 variables are assigned in the call to IdentifySampleTarget.
    Real trench_x, trench_y, ground_pos;
    Boolean parallel;

    // Max length possible is twice the radius of the arm/scoop (.48), i.e. .96.
    // However, the max value is generally not appropriate because the scoop
    // should not be inserted so deep into the ground.  Here, estimating a
    // reasonable value given the other trenching parameters used.
    Real trench_length = 0.6;

    log_info ("Starting BasicFaultHandling plan...");

    Image:
    {
      // Start iff battery is okay and there are no relevant faults
      // Ignore power faults, monitoring tasks prioritized
      Start BatteryOK && AntennaOK;
      ExitCondition !(BatteryOK && AntennaOK);
      log_info ("** Imaging Landing Site **");
      LibraryCall ImageLandingSite(InstanceName = "BasicFaultHandling",
                                   IgnoreCrash = true);
    }

    // Fault response plan for Image
    if (Image.outcome == INTERRUPTED) 
    {
      // Image was interrupted due to a fault or battery issue
      log_info ("Image was interrupted");
      ImageInterrupted = true;

      // If the issue is power, continue after a pause
      // Reason: Imaging is a crucial mission task
      if (!PowerOK) 
      {
      log_warning
      ("System power issues, mission operations nominally paused...");
      Wait 10;
      }
      else
      {
        //log_warning
        //("Waiting for fault resolution before continuing mission operations...");
        if !BatteryOK
        {
          log_warning("Waiting for battery to be okay...");
        }
        endif;
        if !AntennaOK
        {
          log_warning("Waiting for antenna to be okay...");
        }
        endif;
        while (!BatteryOK || !AntennaOK)
        {
          // Wait 1 second before rechecking, continue when faults resolved
          Wait 3;
        }
        // Resuming operations
        log_info ("Resuming mission operations...");
      }
      endif;
      
    }
    else if (Image.outcome == SUCCESS)
    {
      log_info ("Image succeeded");
    }
    else if (Image.outcome == FAILURE)
    {
      log_info ("Image failed");
    }
    else if (Image.outcome == SKIPPED)
    {
      log_info ("Image was skipped");
      log_info ("** Current Fault Statuses **");
      log_info ("ArmOK: ", ArmOK);
      log_info ("AntennaOK: ", AntennaOK);
      log_info ("PowerOK: ", PowerOK);
      log_info ("SystemOK: ", SystemOK);
    }
    else
    {
      log_info ("Image did not start or other issue occurred...");
    }
    endif;

    // Before continuing the plan
    // re-attempt previous task if it was interrupted
    if (ImageInterrupted) 
    {
      // #TODO Is there a more compact way to call Image again?
      // This may bring up issues
      // because it does not pick up where it left off specifically
      Image:
      {
        // Start iff battery is okay and there are no relevant faults
        // Ignore power faults, monitoring tasks prioritized
        Start BatteryOK && AntennaOK;
        ExitCondition !(BatteryOK && AntennaOK);
        log_info ("** Imaging Landing Site **");
        LibraryCall ImageLandingSite(InstanceName = "BasicFaultHandling",
                                   IgnoreCrash = true);
      }
    }

    Unstow:
    {
      Start BatteryOK && ArmOK && PowerOK;
      ExitCondition !(BatteryOK && ArmOK && PowerOK);
      log_info ("** Unstowing Arm **");
      LibraryCall Unstow;
    }

    // Fault response plan for Unstow
    if (Unstow.outcome == INTERRUPTED) 
    {
      log_info ("Unstow was interrupted");
      UnstowInterrupted = true;
      while (!BatteryOK || !ArmOK || !PowerOK) // # TODO Add timeout to prevent infinite loop
      {
        // Revert to more mission critical task to save energy (monitoring)
        // until faults are resolved
        log_info ("Reverting to imaging from unstowing...");
        Image:
        {
          // Start iff battery is okay and there are no relevant faults
          // Ignore power faults, monitoring tasks prioritized
          Start BatteryOK && AntennaOK;
          ExitCondition !(BatteryOK && AntennaOK);
          log_info ("** Imaging Landing Site **");
          LibraryCall ImageLandingSite(InstanceName = "BasicFaultHandling",
                                   IgnoreCrash = true);
        }
        Wait 1;
      }
        
    }
    else if (Unstow.outcome == SUCCESS)
    {
      log_info ("Unstow succeeded");
    }
    else if (Unstow.outcome == FAILURE)
    {
      log_info ("Unstow failed");
    }
    else if (Image.outcome == SKIPPED)
    {
      log_info ("Unstow was skipped");
      log_info ("** Current Fault Statuses **");
      log_info ("ArmOK: ", ArmOK);
      log_info ("AntennaOK: ", AntennaOK);
      log_info ("PowerOK: ", PowerOK);
      log_info ("SystemOK: ", SystemOK);
    }
    }
    else
    {
      log_info ("Unstow did not start or other issue occurred...");
    }
    endif;

    // Before continuing the plan
    // re-attempt previous task if it was interrupted
    if (UnstowInterrupted)
    {
      // # TODO Is there a more compact way to do this?
      // This may bring up issues
      // because it does not pick up where it left off specifically
      Unstow:
      {
        Start BatteryOK && ArmOK && PowerOK;
        ExitCondition !(BatteryOK && ArmOK && PowerOK);
        log_info ("** Unstowing Arm **");
        LibraryCall Unstow;
      }
    }


    Search:
    {
      Start BatteryOK && ArmOK && PowerOK; //&& ForceTorqueOK
      ExitCondition !(BatteryOK && ArmOK && PowerOK); // && ForceTorqueOK
      log_info ("** Identifying Sample Target **");
      LibraryCall IdentifySampleTarget (X = trench_x,
                                        Y = trench_y,
                                        GroundPos = ground_pos,
                                        Parallel = parallel);
    }

    if (Search.outcome == INTERRUPTED) 
    {
      log_info ("Search was interrupted");
      SearchInterrupted = true;      

      while (!BatteryOK || !ArmOK || !PowerOK) // # TODO Add timeout to prevent infinite loop // Add || !ForceTorqueOK  
      {
        // Revert to more mission critical task to save energy (monitoring)
        // until faults are resolved
        log_info ("Reverting to imaging from unstowing...");
        Image:
        {
          // Start iff battery is okay and there are no relevant faults
          // Ignore power faults, monitoring tasks prioritized
          Start BatteryOK && AntennaOK;
          ExitCondition !(BatteryOK && AntennaOK);
          log_info ("** Imaging Landing Site **");
          LibraryCall ImageLandingSite(InstanceName = "BasicFaultHandling",
                                   IgnoreCrash = true);
        }
        Wait 1; 
      }

    }
    else if (Search.outcome == SUCCESS)
    {
      log_info ("Search succeeded");
    }
    else if (Search.outcome == FAILURE)
    {
      log_info ("Search failed");
    }
    else
    {
      log_info ("Search was skipped");
      log_info ("** Current Fault Statuses **");
      log_info ("ArmOK: ", ArmOK);
      log_info ("AntennaOK: ", AntennaOK);
      log_info ("PowerOK: ", PowerOK);
      log_info ("SystemOK: ", SystemOK);
    }
    endif;

    // Before continuing the plan
    // re-attempt previous task if it was interrupted
    if (SearchInterrupted)
    {
      // # TODO Is there a more compact way to do this?
      // This may bring up issues
      // because it does not pick up where it left off specifically
      Search:
      {
        Start BatteryOK && ArmOK && PowerOK; //&& ForceTorqueOK
        ExitCondition !(BatteryOK && ArmOK && PowerOK); // && ForceTorqueOK
        log_info ("** Identifying Sample Target **");
        LibraryCall IdentifySampleTarget (X = trench_x,
                                        Y = trench_y,
                                        GroundPos = ground_pos,
                                        Parallel = parallel);
      }
    }
    
    log_info ("BasicFaultHandling plan complete.");
    MissionInProgress = false;
  }

}
