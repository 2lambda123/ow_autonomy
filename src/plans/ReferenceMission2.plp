// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// This illustrative and imperfect plan builds on ReferenceMission1 by adding
// rudimentary power fault detection and handling.  The faults are currently
// faked in MonitorPower, a plan that runs concurrently with this one.  The
// handling is simply interrupting the mission sequence, and resuming it when
// the fault clears.  The fault detection is done via explicit checks inserted
// synchronously within the mission sequence.  In most cases this does not
// actually halt the mission and freeze the lander as would be desired.  This is
// because the fault handling is not currently propagated to lower levels of the
// plan: child nodes (library calls), and the commands themselves, which are
// implemented as (non-interruptable) ROS services at this time.  Note that when
// a plan's Invariant condition is false (or Exit condition true), it waits for
// any child nodes that are executing, to finish.

#include "plan-interface.h"

LibraryAction MonitorPower (In Boolean continue,
                            InOut Boolean battery_temp_ok,
                            InOut Boolean battery_life_ok,
                            InOut Boolean battery_charge_ok,
                            InOut Boolean proceed);

LibraryAction ImageLandingSite (In String InstanceName, In Boolean IgnoreCrash);

LibraryAction IdentifySampleTarget (InOut Real X,
                                    InOut Real Y,
                                    InOut Boolean Parallel,
                                    InOut Real GroundPos);

LibraryAction DigTrench (In Real X,
                         In Real Y,
                         In Real GroundPos,
                         In Real Length,
                         In Real BiteDepth,
                         In Integer NumPasses,
                         In Boolean Parallel);

LibraryAction RemoveTailings (In Real X,
                              In Real Y,
                              In Real GroundPos,
                              In Boolean Parallel);

LibraryAction CollectSample (In Real X,
                             In Real Y,
                             In Real GroundPos,
                             In Real Depth,
                             In Real Length,
                             In Boolean Parallel);

LibraryAction StartSampleAnalysis;

ReferenceMission2: Concurrence
{
  Integer MissionAttempts = 0;

  // Guards
  Boolean ProceedWithMission = true;
  Boolean MissionInProgress = true;

  // Power monitoring
  Boolean BatteryTempOK = true;
  Boolean BatteryLifeOK = true;
  Boolean BatteryChargeOK = true;

  LibraryCall MonitorPower (continue = MissionInProgress,
                            battery_temp_ok = BatteryTempOK,
                            battery_life_ok = BatteryLifeOK,
                            battery_charge_ok = BatteryChargeOK,
                            proceed = ProceedWithMission);
  WaitForPower:
  {
    Repeat MissionInProgress;
    Start MissionInProgress && !ProceedWithMission;
    Skip !MissionInProgress;

    log_warning
      ("Battery issues, mission operations nominally paused...");
    Wait 10;
  }

  Mission:
  {
    // Mission state
    Boolean ImagingLandingSite = false;
    Boolean UnstowingArm = false;
    Boolean SearchingWorkspace = false;
    Boolean DiggingTrench = false;
    Boolean RemovingTailings = false;
    Boolean CollectingSample = false;
    Boolean StowingArm = false;
    Boolean AnalyzingSample = false;

    // These 4 variables are assigned in the call to IdentifySampleTarget.
    Real trench_x, trench_y, ground_pos;
    Boolean parallel;

    // Max length possible is twice the radius of the arm/scoop (.48), i.e. .96.
    // However, the max value is generally not appropriate because the scoop
    // should not be inserted so deep into the ground.  Here, estimating a
    // reasonable value given the other trenching parameters used.
    Real trench_length = 0.6;

    log_info ("Starting ReferenceMission2 plan...");

    MissionAttempt:
    {

      // The workaround includes this synchonously checked flag.
      Boolean Continue = true;

      // The Invariant works to stop (and fail) this node when there's an issue,
      // but there's a serious problem in that an ongoing command is not
      // explicitly aborted (and this is not even possible with the ROS Service
      // implementation used by this branch), and so the result is unspecified,
      // and not mission-realistic.  The workaround for now is to let each
      // command finish before handling an interruption of this plan, and check
      // ProceedWithMission before each command.  Later, we need to add
      // command-level fault/interruption handling.
      //
      Invariant ProceedWithMission;

      // Note that even when false, an executing child node will be allowed to
      // finish.
      //      Invariant Continue;

      Repeat MissionInProgress && !AnalyzingSample;
      Start MissionInProgress && ProceedWithMission;
      Skip !MissionInProgress;

      MissionAttempts = MissionAttempts + 1;
      log_info (">> Starting mission sequence, attempt ", MissionAttempts, "<<");

      Continue = ProceedWithMission;
      if (! ImagingLandingSite) {
        ImagingLandingSite = true;
        log_info ("** Imaging Landing Site **");
        LibraryCall ImageLandingSite(InstanceName = "ReferenceMission2",
                                     IgnoreCrash = true);
      }

      Continue = ProceedWithMission;
      if (! UnstowingArm) {
        UnstowingArm = true;
        log_info ("** Unstowing Arm **");
        LibraryCall Unstow;
      }

      Continue = ProceedWithMission;
      if (! SearchingWorkspace) {
        SearchingWorkspace = true;
        log_info ("** Identifying Sample Target **");
        LibraryCall IdentifySampleTarget (X = trench_x,
                                          Y = trench_y,
                                          GroundPos = ground_pos,
                                          Parallel = parallel);
      }

      if (Lookup(GroundFound)) {
        Continue = ProceedWithMission;
        if (! DiggingTrench) {
          DiggingTrench = true;
          log_info ("** Digging Trench **");
          LibraryCall DigTrench (X = trench_x,
                                 Y = trench_y,
                                 GroundPos = ground_pos,
                                 Length = trench_length,
                                 BiteDepth = 0.05,
                                 NumPasses = 2,
                                 Parallel = parallel);
        }

        Continue = ProceedWithMission;
        if (! RemovingTailings) {
          RemovingTailings = true;
          log_info ("** Removing Tailings **");
          LibraryCall RemoveTailings (X = trench_x,
                                      Y = trench_y,
                                      GroundPos = ground_pos,
                                      Parallel = parallel);
        }

        Continue = ProceedWithMission;
        if (! CollectingSample) {
          CollectingSample = true;
          log_info ("** Collecting Sample **");
          LibraryCall CollectSample (X = trench_x,
                                     Y = trench_y,
                                     GroundPos = ground_pos,
                                     Depth = 0.11,
                                     Length = trench_length,
                                     Parallel = parallel);
        }

        Continue = ProceedWithMission;
        if (! StowingArm) {
          StowingArm = true;
          log_info ("** Stowing Arm **");
          LibraryCall Stow;
        }

        Continue = ProceedWithMission;
        if (! AnalyzingSample) {
          AnalyzingSample = true;
          log_info ("** Analyzing Sample **");
          LibraryCall StartSampleAnalysis;
        }
      }
      else
        {
          log_error ("Failed to find ground, aborting.");
          Continue = ProceedWithMission;
          if (! StowingArm) {
            StowingArm = true;
            log_info ("** Stowing Arm **");
            LibraryCall Stow;
          }
        }
      endif;
      log_info ("Mission attempt ", MissionAttempts, " completed!");
      MissionInProgress = false;
    }
    log_info ("ReferenceMission2 plan complete.");
  }
}
