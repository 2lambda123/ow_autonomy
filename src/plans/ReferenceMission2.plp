// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// This illustrative and imperfect plan builds on ReferenceMission1 by adding
// rudimentary power fault detection and handling.  The faults are currently
// faked in MonitorPower, a plan that runs concurrently with this one.  The
// handling is simply interrupting the mission sequence, and resuming it when
// the fault clears.  The fault detection is done via explicit checks inserted
// synchronously within the mission sequence.  In most cases this does not
// actually halt the mission and freeze the lander as would be desired.  This is
// because the fault handling is not currently propagated to lower levels of the
// plan: child nodes (library calls), and the commands themselves, which are
// implemented as (non-interruptable) ROS services at this time.  Note that when
// a plan's Invariant condition is false (or Exit condition true), it waits for
// any child nodes that are executing, to finish.

#include "plan-interface.h"

LibraryAction MonitorPower (In Boolean continue,
                            InOut Boolean battery_temp_ok,
                            InOut Boolean battery_life_ok,
                            InOut Boolean battery_charge_ok,
                            InOut Boolean proceed);

LibraryAction UnstowAndConfirm (InOut Boolean Confirm);

LibraryAction StowAndConfirm (InOut Boolean Confirm);

LibraryAction ImageLandingSiteAndConfirm (In String InstanceName,
                                          In Boolean IgnoreCrash,
                                          InOut Boolean Confirm);

LibraryAction IdentifySampleTargetAndConfirm (InOut Real X,
                                              InOut Real Y,
                                              InOut Boolean Parallel,
                                              InOut Real GroundPos,
                                              InOut Boolean Confirm);

LibraryAction DigTrenchAndConfirm (In Real X,
                                   In Real Y,
                                   In Real GroundPos,
                                   In Real Length,
                                   In Real BiteDepth,
                                   In Integer NumPasses,
                                   In Boolean Parallel,
                                   InOut Boolean Confirm);

LibraryAction RemoveTailingsAndConfirm (In Real X,
                                        In Real Y,
                                        In Real GroundPos,
                                        In Boolean Parallel,
                                        InOut Boolean Confirm);

LibraryAction CollectSampleAndConfirm (In Real X,
                                       In Real Y,
                                       In Real GroundPos,
                                       In Real Depth,
                                       In Real Length,
                                       In Boolean Parallel,
                                       InOut Boolean Confirm);

LibraryAction StartSampleAnalysisAndConfirm (InOut Boolean Confirm);

ReferenceMission2: Concurrence
{
  Integer MissionAttempts = 0;

  // Guards
  Boolean ProceedWithMission = true;
  Boolean MissionInProgress = true;

  // Power monitoring
  Boolean BatteryTempOK = true;
  Boolean BatteryLifeOK = true;
  Boolean BatteryChargeOK = true;

  LibraryCall MonitorPower (continue = MissionInProgress,
                            battery_temp_ok = BatteryTempOK,
                            battery_life_ok = BatteryLifeOK,
                            battery_charge_ok = BatteryChargeOK,
                            proceed = ProceedWithMission);
  WaitForPower:
  {
    Repeat MissionInProgress;
    Start MissionInProgress && !ProceedWithMission;
    Skip !MissionInProgress;

    log_warning
      ("Battery issues, mission operations nominally paused...");
    Wait 10;
  }

  Mission:
  {
    // Mission state
    Boolean LandingSiteImaged = false;
    Boolean ArmUnstowed = false;
    Boolean WorkspaceSearched = false;
    Boolean TrenchDug = false;
    Boolean TailingsRemoved = false; // combine with trench dig?
    Boolean SampleCollected = false;
    Boolean ArmStowed = false;
    Boolean SampleAnalysisFinished = false;

    // These 4 variables are assigned in the call to IdentifySampleTarget.
    Real trench_x, trench_y, ground_pos;
    Boolean parallel;

    // Max length possible is twice the radius of the arm/scoop (.48), i.e. .96.
    // However, the max value is generally not appropriate because the scoop
    // should not be inserted so deep into the ground.  Here, estimating a
    // reasonable value given the other trenching parameters used.
    Real trench_length = 0.6;

    log_info ("Starting ReferenceMission2 plan...");

    MissionAttempt:
    {

      // The workaround includes this synchonously checked flag.
      Boolean Continue = true;

      // The Invariant works to stop (and fail) this node when there's an issue,
      // but there's a serious problem in that an ongoing command is not
      // explicitly aborted (and this is not even possible with the ROS Service
      // implementation used by this branch), and so the result is unspecified,
      // and not mission-realistic.  The workaround for now is to let each
      // command finish before handling an interruption of this plan, and check
      // ProceedWithMission before each command.  Later, we need to add
      // command-level fault/interruption handling.
      //
      Invariant ProceedWithMission;

      // Note that even when false, an executing child node will be allowed to
      // finish.
      //      Invariant Continue;

      Repeat MissionInProgress && !SampleAnalysisFinished;
      Start MissionInProgress && ProceedWithMission;
      Skip !MissionInProgress;

      MissionAttempts = MissionAttempts + 1;
      log_info (">> Starting mission sequence, attempt ", MissionAttempts, "<<");

      Continue = ProceedWithMission;
      if (! LandingSiteImaged) {
        log_info ("** Imaging Landing Site **");
        LibraryCall ImageLandingSiteAndConfirm (InstanceName = "ReferenceMission2",
                                                IgnoreCrash = true,
                                                Confirm = LandingSiteImaged);
      }

      Continue = ProceedWithMission;
      if (! ArmUnstowed) {
        log_info ("** Unstowing Arm **");
        LibraryCall UnstowAndConfirm (Confirm = ArmUnstowed);
      }

      Continue = ProceedWithMission;
      if (! WorkspaceSearched) {
        log_info ("** Identifying Sample Target **");
        LibraryCall IdentifySampleTargetAndConfirm (X = trench_x,
                                                    Y = trench_y,
                                                    GroundPos = ground_pos,
                                                    Parallel = parallel,
                                                    Confirm = WorkspaceSearched);
      }

      if (Lookup(GroundFound)) {
        Continue = ProceedWithMission;
        if (! TrenchDug) {
          log_info ("** Digging Trench **");
          LibraryCall DigTrenchAndConfirm (X = trench_x,
                                           Y = trench_y,
                                           GroundPos = ground_pos,
                                           Length = trench_length,
                                           BiteDepth = 0.05,
                                           NumPasses = 2,
                                           Parallel = parallel,
                                           Confirm = TrenchDug);
        }

        Continue = ProceedWithMission;
        if (! TailingsRemoved) {
          log_info ("** Removing Tailings **");
          LibraryCall RemoveTailingsAndConfirm (X = trench_x,
                                                Y = trench_y,
                                                GroundPos = ground_pos,
                                                Parallel = parallel,
                                                Confirm = TailingsRemoved);
        }

        Continue = ProceedWithMission;
        if (! SampleCollected) {
          log_info ("** Collecting Sample **");
          LibraryCall CollectSampleAndConfirm (X = trench_x,
                                               Y = trench_y,
                                               GroundPos = ground_pos,
                                               Depth = 0.11,
                                               Length = trench_length,
                                               Parallel = parallel,
                                               Confirm = SampleCollected);
        }

        Continue = ProceedWithMission;
        if (! ArmStowed) {
          log_info ("** Stowing Arm **");
          LibraryCall StowAndConfirm (Confirm = ArmStowed);
        }

        Continue = ProceedWithMission;
        if (! SampleAnalysisFinished) {
          log_info ("** Analyzing Sample **");
          LibraryCall StartSampleAnalysisAndConfirm
            (Confirm = SampleAnalysisFinished);
        }
      }
      else
        {
          log_error ("Failed to find ground, aborting.");
          Continue = ProceedWithMission;
          if (! ArmStowed) {
            log_info ("** Stowing Arm **");
            LibraryCall StowAndConfirm (Confirm = ArmStowed);
          }
        }
      endif;
      log_info ("Mission attempt ", MissionAttempts, " completed!");
      MissionInProgress = false;
    }
    log_info ("ReferenceMission2 plan complete.");
  }
}
