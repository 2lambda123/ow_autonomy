// High-level notional plan for lander autonomy.

// __BEGIN_LICENSE__
// Copyright (c) 2018-2019, United States Government as represented by the
// Administrator of the National Aeronautics and Space Administration. All
// rights reserved.
// __END_LICENSE__

/* To Do:
   - deal with potential random resets, i.e. due to radiation
   - save/resume state across sleep/wake cycle
   - fail operational
   - for each timeout: retry/failure semantics
*/

#include "OceanWorldDefs.h"


Real Lookup TrenchLength;
Real Lookup TrenchWidth;
Real Lookup TrenchDepth;
Real Lookup TrenchYaw;
Real Lookup TrenchPitch;
Real Lookup TrenchSlopeAngle;
Real Lookup TrenchStartX;
Real Lookup TrenchStartY;
Real Lookup TrenchStartZ;
Real Lookup TrenchDumpX;
Real Lookup TrenchDumpY;
Real Lookup TrenchDumpZ;
Boolean Lookup TrenchIdentified;

Boolean Lookup SampleGood;

Real Lookup time;
Real Lookup ExcavationTimeout;
Real Lookup TrenchTargetTimeout;
Real Lookup CollectAndTransferTimeout;


LibraryAction Stub(In String desc);
LibraryAction Downlink();
LibraryAction Image(In String desc);
LibraryAction DownlinkImage();
LibraryAction ImageSampleSite();

Command pprint (...);

// This declaration should work, but does not.
// String Command StartPlan(String plan_name, ...);

String Command StartPlan(...);

// The following is taken from the draft JPL lander command dictionary.

Boolean Command DigTrench (Real startX, Real startY, Real startZ,
                           Real depth, Real length, Real width,
                           Real pitch, Real yaw,
                           Real dumpX, Real dumpY, Real dumpZ);

// The following are taken from the Phoenix lander activity dictionary.
Command RA_COLLECT ();
Command ALIGN_SAMPLE_AND_CAMERA ();

// TODO: find out what this is for
Command hga_comm (Real duration);

OceanWorldMission: Concurrence
{
    // Assumption: checkout is complete before this node starts.

    ContingencyMonitors: Concurrence
    {
        BatteryMonitor:
        {
            LibraryCall Stub(desc="Monitoring battery");
        }
        ThermalMonitor:
        {
            LibraryCall Stub(desc="Monitoring thermal");
        }
        UplinkMonitor:
        {
            LibraryCall Stub(desc="Monitoring for uplinks");
        }
    }

    Mission:
    {
        Boolean DeepEnough = false;
        Boolean CollectMore = true;

        Real Time;

        Panorama:
        {
            StereoImage:
            {
                LibraryCall Stub(desc="Taking stereo panorama of landing site");
            }
        }

        ImageWorkspace:
        {
            LibraryCall Image(desc="workspace");
        }

        SurfaceInterrogation:
        {
            LibraryCall Stub(desc="Interrogating surface");
        }

        GetTrenchTarget:
        {
            // TODO: invoke comms, reset on failure.
            LibraryCall DownlinkImage();
            Try
            {
                GetInfoFromGround:
                {
                    Integer numAttempts = 0;
                    RepeatCondition AttemptGround.outcome == FAILURE;
                    InvariantCondition numAttempts <= 1;
                    Time = Lookup(time);
                    AttemptGround:
                    {
                        InvariantCondition
                            Time < (AttemptGround.EXECUTING.START +
                                     Lookup(TrenchTargetTimeout));
                        EndCondition Lookup(TrenchIdentified);
                        LibraryCall Stub(desc="Getting trench target from ground");
                        numAttempts = numAttempts + 1;
                    }
                }
                pprint ("failed.");
                GetTrenchTargetOnboard:
                {
                    LibraryCall Stub(desc="Getting trench target onboard");
                }
            }
        }

        Time = Lookup(time);

        Excavation:
        {
            RepeatCondition !DeepEnough;
            InvariantCondition
                Time < (Excavation.EXECUTING.START + Lookup(ExcavationTimeout));
            DigAndFilm: Concurrence
            {
                Boolean DiggingSafe = true;

                DigTheTrench:
                {
                    InvariantCondition DiggingSafe;
                    EndCondition (Dig.command_handle == COMMAND_SUCCESS ||
                                  Time >= (DigTheTrench.EXECUTING.START
                                           + DigTrenchTimeout));
                    Dig:
                    {
                        Boolean success;
                        success = DigTrench (Lookup(TrenchStartX),
                                             Lookup(TrenchStartY),
                                             Lookup(TrenchStartZ),
                                             Lookup(TrenchDepth),
                                             Lookup(TrenchLength),
                                             Lookup(TrenchWidth),
                                             Lookup(TrenchPitch),
                                             Lookup(TrenchYaw),
                                             Lookup(TrenchDumpX),
                                             Lookup(TrenchDumpY),
                                             Lookup(TrenchDumpZ));
                    }
                    FilmDig:
                    {
                        Repeat DigTheTrench.state == EXECUTING;
                        LibraryCall Image(desc="trench");
                        Wait FilmInterval;
                    }
                    SenseDig:
                    {
                        Repeat DigTheTrench.state == EXECUTING;
                        pprint ("Sensing dig...");
                        DiggingSafe = StubTrue;
                        Wait SenseDigInterval;
                    }
                }
            }
            RemoveTailings:
            {
                LibraryCall Stub(desc="Removing tailings");
            }
            LibraryCall Image(desc="dig");
            AssessDepth:
            {
                DeepEnough = StubTrue;
            }
        }

        LibraryCall Downlink();
        Time = Lookup(time);

        CollectionAndTransfer:
        {
            Real SampleAmount;
            InvariantCondition
                Time < (CollectionAndTransfer.EXECUTING.START +
                        Lookup(CollectAndTransferTimeout));
            RepeatCondition CollectMore;
            Collect:
            {
                EndCondition Lookup(SampleGood); // Material Property Sensing
                RA_COLLECT();
            }
            ImageSample:
            {
                ALIGN_SAMPLE_AND_CAMERA();  // position arm for imaging
                LibraryCall Image(desc="sample");
            }
            DownlinkSampleImage:
            {
                LibraryCall Downlink();
            }
            Transfer:
            {
                Dock:
                {
                    LibraryCall Stub(desc="Docking");
                }
                Unload:
                {
                    LibraryCall Stub(desc="Unloading");
                }
                MeasureSample:
                {
                    PostCondition !CollectMore;
                    LibraryCall Stub(desc="Measuring Sample");
                    CollectMore = StubFalse;
                    Wait 1;
                }
                CapSample:
                {
                    LibraryCall Stub(desc="Capping Sample");
                }
                DeliverSample:
                {
                    LibraryCall Stub(desc="Delivering Sample");
                }
                LibraryCall ImageSampleSite();
            }
        }
        DoSampleAnalysis:
        {
            // Spawn a plan that does analysis.
            // Persists through sleep/wake cycle.
            // Details outside scope of our simulation.
            // Model time, energy, and possibly temperature.
            String id;
            id = StartPlan("SampleAnalysis", "instrument", 1);
        }
    }
}
