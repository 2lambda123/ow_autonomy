// High-level notional plan for lander autonomy.

/* To Do:
   - deal with potential random resets, i.e. due to radiation
   - save/resume state across sleep/wake cycle
   - fail operational
   - for each timeout: retry/failure semantics
*/

#include "OceanWorldDefs.h"


Real Lookup TrenchLength;
Real Lookup TrenchWidth;
Real Lookup TrenchDepth;
Real Lookup TrenchSlopeAngle;
Real[3] Lookup TrenchStart;
Boolean Lookup TrenchIdentified;

Boolean Lookup SampleGood;

Real Lookup time;
Real Lookup ExcavationTimeout;
Real Lookup TrenchTargetTimeout;
Real Lookup CollectAndTransferTimeout;


LibraryAction Stub(In String desc);
LibraryAction Downlink();
LibraryAction Image(In String desc);
LibraryAction DownlinkImage();
LibraryAction ImageSampleSite();

Command pprint (...);

// This declaration should work, but does not.
// String Command StartPlan(String plan_name, ...);

String Command StartPlan(...);

// The following are adapted from the Phoenix lander activity dictionary.

Command RA_DIG (Real length, Real width, Real depth,
                Real slope_angle, Real trench_start[3],
                Real data_generation_rate, Real energy_consumption_rate);

Command RA_COLLECT ();
Command ALIGN_SAMPLE_AND_CAMERA ();

// TODO: find out what this is for
Command hga_comm (Real duration);

OceanWorldMission: Concurrence
{
    // Assumption: checkout is complete before this node starts.

    ContingencyMonitors: Concurrence
    {
        BatteryMonitor:
        {
            LibraryCall Stub(desc="Monitoring battery");
        }
        ThermalMonitor:
        {
            LibraryCall Stub(desc="Monitoring thermal");
        }
        UplinkMonitor:
        {
            LibraryCall Stub(desc="Monitoring for uplinks");
        }
    }

    Mission:
    {
        Boolean DeepEnough = false;
        Boolean CollectMore = true;

        Real Time;
    
        Panorama:
        {
            StereoImage:
            {
                LibraryCall Stub(desc="Taking stereo panorama of landing site");
            }
        }

        ImageWorkspace:
        {
            LibraryCall Image(desc="workspace");
        }

        SurfaceInterrogation:
        {
            LibraryCall Stub(desc="Interrogating surface");
        }

        GetTrenchTarget:
        {
            // TODO: invoke comms, reset on failure.
            LibraryCall DownlinkImage();
            Try
            {
                GetInfoFromGround:
                {
                    Integer numAttempts = 0;
                    RepeatCondition AttemptGround.outcome == FAILURE;
                    InvariantCondition numAttempts <= 1;
                    Time = Lookup(time);
                    AttemptGround:
                    {
                        InvariantCondition
                            Time < (AttemptGround.EXECUTING.START +
                                     Lookup(TrenchTargetTimeout));
                        EndCondition Lookup(TrenchIdentified);
                        LibraryCall Stub(desc="Getting trench target from ground");
                        numAttempts = numAttempts + 1;
                    }
                }
                pprint ("failed.");
                GetTrenchTargetOnboard:
                {
                    LibraryCall Stub(desc="Getting trench target onboard");
                }
            }
        }

        Time = Lookup(time);
        Excavation:
        {
            RepeatCondition !DeepEnough;
// Needs debugging
//
//            InvariantCondition
//                Lookup(time) < (Excavation.EXECUTING.START +
//                                Lookup(ExcavationTimeout));
            DigAndFilm: Concurrence
                {
                    Boolean DiggingSafe = true;

                    DigTrench:
                    {
                        InvariantCondition DiggingSafe;
                        EndCondition (Dig.command_handle == COMMAND_SUCCESS ||
                                      Time >= (DigTrench.EXECUTING.START
                                               + DigTrenchTimeout));
                        Dig: RA_DIG (Lookup(TrenchLength), Lookup(TrenchWidth),
                                     Lookup(TrenchDepth), Lookup(TrenchSlopeAngle),
                                     Lookup(TrenchStart), DigDataGenerationRate,
                                     DigEnergyConsumptionRate);
                    }
                    FilmDig:
                    {
                        Repeat DigTrench.state == EXECUTING;
                        LibraryCall Image(desc="trench");
                        Wait FilmInterval;
                    }
                    SenseDig:
                    {
                        Repeat DigTrench.state == EXECUTING;
                        pprint ("Sensing dig...");
                        DiggingSafe = StubTrue;
                        Wait SenseDigInterval;
                    }
                }
            RemoveTailings:
            {
                LibraryCall Stub(desc="Removing tailings");
            }
            LibraryCall Image(desc="dig");
            AssessDepth:
            {
                DeepEnough = StubTrue;
            }
        }

        LibraryCall Downlink();
        Time = Lookup(time);
        CollectionAndTransfer:
        {
            Real SampleAmount;
// Needs debugging
           InvariantCondition
               Time < (CollectionAndTransfer.EXECUTING.START +
                       Lookup(CollectAndTransferTimeout));
            RepeatCondition CollectMore;
            Collect:
            {
                EndCondition Lookup(SampleGood); // Material Property Sensing
                RA_COLLECT();
            }
            ImageSample:
            {
                ALIGN_SAMPLE_AND_CAMERA();  // position arm for imaging
                LibraryCall Image(desc="sample");
            }
            DownlinkSampleImage:
            {
                LibraryCall Downlink();
            }
            Transfer:
            {
                Dock:
                {
                    LibraryCall Stub(desc="Docking");
                }
                Unload:
                {
                    LibraryCall Stub(desc="Unloading");
                }
                MeasureSample:
                {
                    PostCondition !CollectMore;
                    LibraryCall Stub(desc="Measuring Sample");
                    CollectMore = StubFalse;
                    Wait 1;
                }
                CapSample:
                {
                    LibraryCall Stub(desc="Capping Sample");
                }
                DeliverSample:
                {
                    LibraryCall Stub(desc="Delivering Sample");
                }
                LibraryCall ImageSampleSite();
            }
        }
        DoSampleAnalysis:
        {
            // Spawn a plan that does analysis.
            // Persists through sleep/wake cycle.
            // Details outside scope of our simulation.
            // Model time, energy, and possibly temperature.
            String id;
            id = StartPlan("SampleAnalysis", "instrument", 1);
        }
    }
}
