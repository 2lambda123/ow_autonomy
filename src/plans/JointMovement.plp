// The Notices and Disclaimers for Ocean Worlds Autonomy Testbed for Exploration
// Research and Simulation can be found in README.md in the root directory of
// this repository.

// Generic invocation of a real-valued joint movement command.

// Inputs:
//   New value to be commanded (unitless here, could e.g. be degrees)
//   Name of lookup for current value of commanded value
//   Name of lookup for joint velocity
//   Name of command, which must take a single real-number argument

// Possible todos:
//  - preconditions to check for resource availability, etc.
//  - handle failure (e.g. retry)

#include "plexil_defs.h"

Real Lookup time;
Command stop_operation (String name);
Command log_error (...);
Command log_info (...);

LibraryAction RealValuedCommand (In String OpName, In Real Value,
                                 InOut Boolean Result);

JointMovement: CheckedSequence
{
  In Real NewValue;
  In String CurrentValueLookup;
  In String VelocityLookup;
  In String OpName;

  Real Tolerance = 0.6;    // degrees, made up
  Real TimeOut   = 5.0;    // unitless, made up
  Boolean PreAchieved = false;

  // First, command the operation, if needed.
  MaybeCommand:
  {
    Boolean CommandSuccess = true;
    PostCondition CommandSuccess;

    if (abs(Lookup((CurrentValueLookup)) - NewValue) <= Tolerance) {
      log_info (OpName, " already at ", NewValue);
      PreAchieved = true;
    }
    else {
      log_info ("Commanding ", OpName, " with ", NewValue);
      LibraryCall RealValuedCommand (OpName = OpName,
                                     Value = NewValue,
                                     Result = CommandSuccess);
    }
    endif;
  }

  // If commanded, wait for movement to start
  WaitForStart:
  {
    SkipCondition PreAchieved;
    EndCondition ((abs(Lookup((VelocityLookup), 0.01)) > ZERO_VEL) ||
                  Lookup(time, 1) - WaitForStart.EXECUTING.START > TimeOut);
  }

  // If commanded, wait for movement to stop.
  WaitForEnd:
  {
    SkipCondition PreAchieved;
    EndCondition ((abs(Lookup((VelocityLookup), 0.01)) <= ZERO_VEL) ||
                  Lookup(time, 1) - WaitForEnd.EXECUTING.START > TimeOut);
  }

  // If commanded, stop the command.  This step is needed because the underlying
  // C++ does not know that the movement has stopped, and needs to terminate the
  // the fault monitoring thread which is detached.  In the future we might want
  // to push all the joint movement logic into C++.
  Stop:
  {
    SkipCondition PreAchieved;
    stop_operation (OpName);
  }

  // Report failure if needed.

  // NOTE: on rare occasions this node fails spuriously and mysteriously: the
  // pan appears to be successful, as indicated by the current/new values being
  // equal.

  ReportFailure:
  {
    SkipCondition (PreAchieved ||
                   abs(Lookup((CurrentValueLookup)) - NewValue) <= Tolerance);
    PostCondition  false; // This forces root node to fail, a design choice.
    log_error (OpName, " failed. (", Lookup((CurrentValueLookup)), ", ",
               NewValue, ")");
  }
}
